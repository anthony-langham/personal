---
// Interactive orb component that follows cursor movement
---

<div class="interactive-orb-container">
  <div id="interactive-orb" class="orb">
    <div class="orb-inner"></div>
  </div>
</div>

<style>
  .interactive-orb-container {
    position: relative;
    width: 40px;
    height: 40px;
    cursor: pointer;
  }

  .orb {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: radial-gradient(
      circle at 30% 30%,
      rgba(99, 102, 241, 0.8),
      rgba(139, 92, 246, 0.6),
      rgba(236, 72, 153, 0.4)
    );
    position: relative;
    transition: transform 0.2s ease-out;
    animation: float 6s ease-in-out infinite;
  }

  .orb-inner {
    position: absolute;
    width: 60%;
    height: 60%;
    top: 20%;
    left: 20%;
    border-radius: 50%;
    background: radial-gradient(
      circle at 40% 40%,
      rgba(255, 255, 255, 0.8),
      rgba(255, 255, 255, 0.2)
    );
    transition: transform 0.15s ease-out;
  }

  @keyframes float {
    0%, 100% {
      transform: translateY(0px);
    }
    50% {
      transform: translateY(-5px);
    }
  }

  .orb:hover {
    transform: scale(1.1);
  }

  /* Dark mode adjustments */
  :global(.dark) .orb {
    background: radial-gradient(
      circle at 30% 30%,
      rgba(147, 51, 234, 0.9),
      rgba(59, 130, 246, 0.7),
      rgba(34, 211, 238, 0.5)
    );
    box-shadow: 0 0 30px rgba(147, 51, 234, 0.3);
  }
</style>

<script>
  function initInteractiveOrb() {
    const orb = document.getElementById('interactive-orb');
    const orbInner = orb?.querySelector('.orb-inner');
    
    if (!orb || !orbInner) return;

    let animationFrame: number;

    function handleMouseMove(e: MouseEvent) {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }

      animationFrame = requestAnimationFrame(() => {
        const rect = orb.getBoundingClientRect();
        const orbCenterX = rect.left + rect.width / 2;
        const orbCenterY = rect.top + rect.height / 2;
        
        // Calculate distance and angle from orb center to cursor
        const deltaX = e.clientX - orbCenterX;
        const deltaY = e.clientY - orbCenterY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDistance = 300; // Maximum tracking distance
        
        // Limit the effect based on distance
        const effectStrength = Math.min(1, distance / maxDistance);
        const maxMovement = 8; // Maximum pixels the inner orb can move
        
        // Calculate movement for inner orb (inverse direction for depth effect)
        const moveX = -(deltaX / distance) * maxMovement * effectStrength;
        const moveY = -(deltaY / distance) * maxMovement * effectStrength;
        
        // Apply transforms
        if (orbInner instanceof HTMLElement) {
          orbInner.style.transform = `translate(${moveX}px, ${moveY}px)`;
        }
        
        // Subtle gradient shift based on cursor position
        const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
        orb.style.background = `radial-gradient(
          circle at ${30 + moveX}% ${30 + moveY}%,
          rgba(99, 102, 241, 0.8),
          rgba(139, 92, 246, 0.6),
          rgba(236, 72, 153, 0.4)
        )`;
      });
    }

    function handleMouseLeave() {
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
      
      // Reset to default position
      if (orbInner instanceof HTMLElement) {
        orbInner.style.transform = 'translate(0, 0)';
      }
      
      // Reset gradient
      orb.style.background = '';
    }

    // Add event listeners
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseleave', handleMouseLeave);

    // Cleanup function for view transitions
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseleave', handleMouseLeave);
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
      }
    };
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', initInteractiveOrb);
  
  // Reinitialize after view transitions
  document.addEventListener('astro:after-swap', initInteractiveOrb);
</script>